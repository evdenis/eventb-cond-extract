package ru.ispras.eventb_cond_extract;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.eventb.core.ast.*;

/**
 * Extracts all conditions from the Rodin Event-B model.
 * The model must be stored as one statically checked machine
 * in the *.bcm file (generated by Rodin).
 * To get the conditions you should instantiate this class
 * and use the field {@link machineConditions}. You may use
 * the field {@link scMachine} to get access to the machine
 * (to iterate its elements, for example, events). And you
 * may use the field {@link typeEnvironments} for parsing
 * and type-checking the formulas for the machine.
 *
 * Conditions identifiers for events are formed as
 * &lt;event-label&gt;/&lt;guard-name&gt;/&lt;index&gt;.
 * Each condition in the guard has its own index. Conditions
 * indexes are started from 1 and increased continuously
 * by depth-first visiting.
 *
 * Conditions identifiers for invariants are formed as
 * &lt;invariant-label&gt;/&lt;index&gt;.
 * 
 * Here is the list of operators which are splitted and when:
 * <ul>
 * <li>conjunction (always)</li>
 * <li>disjunction (always)</li>
 * <li>implication (always)</li>
 * <li>equivalence (always)</li>
 * <li>negation (always)</li>
 * <li>relations: not equal, less, less than, greater, greater than,
 * 	contains, not contains, is subset, is subset or equal,
 * 	is not subset, is not subset or equal (are splitted
 * 	only if there are one of the part in the same event)</li>
 * </ul>
 */
public final class ConditionsExtractor {

	/**
	 * Statically checked machine used for conditions extraction.
	 */
	public final StaticallyCheckedMachine scMachine;

	/**
	 * Type environments of the machine.
	 */
	public final TypeEnvironmentsHolder typeEnvironments;

	/**
	 * Conditions for events and invariants of the machine.
	 *
	 * Immutable.
	 */
	public final MachineConditions machineConditions;

	/**
	 *
	 * @param scMachine	statically checked machine for conditions extraction
	 * @throws IllegalArgumentException	if scMachine has incorrect predicate
	 */
	public ConditionsExtractor(final StaticallyCheckedMachine scMachine) {
		this.scMachine = scMachine;
		this.typeEnvironments = new TypeEnvironmentsHolder(scMachine);
		this.machineConditions = new MachineConditions(
				makeEventsConditions(),
				makeInvariantsConditions());
	}

	private Map<String, KeySuppliedSequence<String, Condition>> makeEventsConditions() {
		return scMachine.events.values.stream().collect(Collectors.toMap(
					event -> event.label,
					event -> makeEventConditions(event)));
	}

	private KeySuppliedSequence<String, Condition> makeEventConditions(final StaticallyCheckedEvent event) {
		final ITypeEnvironment typeEnvironment = typeEnvironments.eventsTypeEnvironments.get(event.label);
		final List<Condition> conditions = new ArrayList<>();

		event.guards.values.forEach(guard -> {
			final List<Predicate> predicates = PredicateSplitter.splitToConditions(getGuardPredicate(guard));
			IntStream.range(0, predicates.size()).forEach(i -> {
				final Predicate predicate = predicates.get(i);
				final String conditionId = String.format("%s/%s/%d", event.label, guard.label, i + 1);
				final boolean isConst = PredicateConstChecker.isConst(predicate, scMachine, event);
				final String wdPredicate = WDComputer.computeWDPredicate(predicate, typeEnvironment);
				final Condition condition = new Condition(conditionId, predicate, isConst, wdPredicate);

				conditions.add(condition);
			});
		});

		return new KeySuppliedSequence<>(conditions, c -> c.id);
	}

	private Map<String, KeySuppliedSequence<String, Condition>> makeInvariantsConditions() {
		return scMachine.invariants.values.stream().collect(Collectors.toMap(
					invariant -> invariant.label,
					invariant -> makeInvariantConditions(invariant)));
	}

	private KeySuppliedSequence<String, Condition> makeInvariantConditions(
			final StaticallyCheckedInvariant invariant) {
		final ITypeEnvironment typeEnvironment = typeEnvironments.variablesTypeEnvironment;
		final List<Condition> conditions = new ArrayList<>();

		final List<Predicate> predicates = PredicateSplitter.splitToConditions(getInvariantPredicate(invariant));
		IntStream.range(0, predicates.size()).forEach(i -> {
			final Predicate predicate = predicates.get(i);
			final String conditionId = String.format("%s/%d", invariant.label, i + 1);
			final boolean isConst = PredicateConstChecker.isConst(predicate, scMachine, null);
			final String wdPredicate = WDComputer.computeWDPredicate(predicate, typeEnvironment);
			final Condition condition = new Condition(conditionId, predicate, isConst, wdPredicate);
			conditions.add(condition);
		});

		return new KeySuppliedSequence<>(conditions, c -> c.id);
	}

	private Predicate getGuardPredicate(final StaticallyCheckedGuard guard) {
		final IParseResult parsedFormula = typeEnvironments.ff.parsePredicate(guard.predicate, null);
		final Predicate predicate = parsedFormula.getParsedPredicate();
		if (parsedFormula.hasProblem()) {
			throw new IllegalArgumentException(
				Stream.concat(
					Stream.of("Cannot parse guard " + guard.label + ": " + guard.predicate + ":"),
					parsedFormula.getProblems().stream().map(Object::toString))
				.collect(Collectors.joining(System.lineSeparator())));
		}
		return predicate;
	}

	private Predicate getInvariantPredicate(final StaticallyCheckedInvariant inv) {
		final IParseResult parsedFormula = typeEnvironments.ff.parsePredicate(inv.predicate, null);
		final Predicate predicate = parsedFormula.getParsedPredicate();
		if (parsedFormula.hasProblem()) {
			throw new IllegalArgumentException(
				Stream.concat(
					Stream.of("Cannot parse invariant " + inv.label + ": " + inv.predicate + ":"),
					parsedFormula.getProblems().stream().map(Object::toString))
				.collect(Collectors.joining(System.lineSeparator())));
		}
		return predicate;
	}
}